Index: src/de/umr/fixcon/graphFunctions/GraphFunction.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon.graphFunctions\r\n\r\nimport de.umr.core.dataStructures.VertexOrderedGraph\r\nimport de.umr.core.vertexCount\r\nimport org.jgrapht.Graph\r\nimport org.jgrapht.graph.DefaultEdge\r\n\r\n/**Specifies an interface any function that maps a finite graph to a real number must fulfill.*/\r\ninterface GraphFunction {\r\n\r\n    //TODO comment\r\n    val vertexAdditionBound: Int get() = 0\r\n\r\n    /**A function fulfills [isEdgeMonotone] if the inclusion of new edges into a graph\r\n     * can't lower the resulting value of the function on this graph*/\r\n    val isEdgeMonotone: Boolean\r\n        get() = false\r\n\r\n    /**An objective function *f* is vertex-addition-bounded by value *x*, if for every graph *G* and\r\n    all graphs *G'* that are obtained by adding some vertex to *G* and making this vertex adjacent to\r\n    some subset of *Vertices(G)*, we have *f(G')* less-or-equal *f(G)* + *x*.*/\r\n    fun <V> completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int> = emptyList()) =\r\n            (targetSize - subgraph.vertexCount) * vertexAdditionBound\r\n\r\n    /**Applies the function to a graph and returns the resulting real number*/\r\n    fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int> = emptyList()): Int\r\n\r\n    /**Returns the optimum value the function can return for a graph of the size [graphSize]\r\n     * [graphSize] has a default-value because for some functions it's not needed, e.g. for decision-problems\r\n     * The default value of this function is 1, which is the [globalOptimum] for decision-problems*/\r\n    fun globalOptimum(graphSize: Int = -123/*Functions that need graphSize throw exception at -123*/): Int = 1\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/graphFunctions/GraphFunction.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/graphFunctions/GraphFunction.kt	(date 1592289269839)
@@ -30,4 +30,5 @@
      * The default value of this function is 1, which is the [globalOptimum] for decision-problems*/
     fun globalOptimum(graphSize: Int = -123/*Functions that need graphSize throw exception at -123*/): Int = 1
 
+    fun degOneOptimum(graphSize: Int): Int
 }
\ No newline at end of file
Index: src/de/umr/fixcon/Solver.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon\r\n\r\nimport de.umr.core.vertexCount\r\nimport de.umr.fixcon.heuristics.LowerBoundGenerator\r\nimport de.umr.fixcon.itarators.SubIterator\r\nimport de.umr.fixcon.wrappers.CFCO_Problem\r\nimport de.umr.fixcon.wrappers.Solution\r\n\r\nclass Solver<V>(private val problem: CFCO_Problem<V>) {\r\n\r\n    private val useHeuristic: Boolean = false\r\n\r\n    private val bestSolution = if (useHeuristic) LowerBoundGenerator(problem).getBound() else Solution()\r\n    //private val bestSolution = Solution(SimpleGraph(DefaultEdge::class.java), 14)\r\n\r\n    private var iter = subIterAtAnyVertex()\r\n\r\n    fun solve(): Solution<V> {\r\n\r\n        fun updateStartVertexIfNeeded() {\r\n            while (!iter.isValid && problem.originalGraph.vertexCount > problem.targetSize) {\r\n                problem.originalGraph.removeVertex(iter.startVertex)\r\n                iter = subIterAtAnyVertex()\r\n            }\r\n        }\r\n\r\n        while (bestSolution.value < problem.function.globalOptimum(problem.targetSize) && iter.isValid) {\r\n            iter.mutate()\r\n            updateStartVertexIfNeeded()\r\n        }\r\n        return bestSolution\r\n    }\r\n\r\n    private fun subIterAtAnyVertex() = SubIterator(problem, problem.originalGraph.vertexSet().first(), bestSolution)\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/Solver.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/Solver.kt	(date 1592299163099)
@@ -8,15 +8,14 @@
 
 class Solver<V>(private val problem: CFCO_Problem<V>) {
 
-    private val useHeuristic: Boolean = false
-
-    private val bestSolution = if (useHeuristic) LowerBoundGenerator(problem).getBound() else Solution()
-    //private val bestSolution = Solution(SimpleGraph(DefaultEdge::class.java), 14)
-
-    private var iter = subIterAtAnyVertex()
+    private val bestSolution = Solution<V>()
 
     fun solve(): Solution<V> {
 
+
+
+        var iter = subIterAtAnyVertex()
+
         fun updateStartVertexIfNeeded() {
             while (!iter.isValid && problem.originalGraph.vertexCount > problem.targetSize) {
                 problem.originalGraph.removeVertex(iter.startVertex)
Index: src/de/umr/fixcon/graphFunctions/standardFunctions/DiameterFunction.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon.graphFunctions.standardFunctions\r\n\r\nimport de.umr.core.dataStructures.VertexOrderedGraph\r\nimport de.umr.core.vertexCount\r\nimport de.umr.fixcon.graphFunctions.GraphFunction\r\nimport org.jgrapht.Graph\r\nimport org.jgrapht.GraphMetrics.getDiameter\r\nimport org.jgrapht.graph.DefaultEdge\r\n\r\nobject DiameterFunction : GraphFunction {\r\n\r\n    override val isEdgeMonotone: Boolean get() = true\r\n\r\n    override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) = getDiameter(g).toInt()\r\n\r\n    /**If every new vertex extends the currently longest path.*/\r\n    override fun <V> completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) =\r\n            targetSize - subgraph.vertexCount\r\n\r\n    /**Path with [graphSize] vertices has [graphSize]-1 edges that form a path.*/\r\n    override fun globalOptimum(graphSize: Int) = graphSize-1\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/graphFunctions/standardFunctions/DiameterFunction.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/graphFunctions/standardFunctions/DiameterFunction.kt	(date 1592289269858)
@@ -18,5 +18,7 @@
             targetSize - subgraph.vertexCount
 
     /**Path with [graphSize] vertices has [graphSize]-1 edges that form a path.*/
-    override fun globalOptimum(graphSize: Int) = graphSize-1
+    override fun globalOptimum(graphSize: Int) = graphSize - 1
+
+    override fun degOneOptimum(graphSize: Int) = throw Exception("not implemented yet")
 }
\ No newline at end of file
Index: src/de/umr/fixcon/graphFunctions/standardFunctions/DegreeConstrainedFunction.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon.graphFunctions.standardFunctions\r\n\r\nimport de.umr.core.dataStructures.VertexOrderedGraph\r\nimport de.umr.fixcon.graphFunctions.GraphFunction\r\nimport org.jgrapht.Graph\r\nimport org.jgrapht.graph.DefaultEdge\r\n\r\n/**This function returns 1 (indicator for **True**) iff the degree of every vertex in the graph\r\n * is inside of the specified range*/\r\nobject DegreeConstrainedFunction : GraphFunction {\r\n\r\n    override fun<V> completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) =\r\n            if (subgraph.vertexSet().any { subgraph.degreeOf(it) > args[0] }) 0 else 1\r\n\r\n    override fun <V>eval(g: Graph<V, DefaultEdge>, args: List<Int>): Int {\r\n        fun rangeBetween(x: Int, y: Int) = if (x <= y) x..y else y..x\r\n        return if (g.vertexSet().all { g.degreeOf(it) in rangeBetween(args[0], args[1]) }) 1 else 0\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/graphFunctions/standardFunctions/DegreeConstrainedFunction.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/graphFunctions/standardFunctions/DegreeConstrainedFunction.kt	(date 1592289269976)
@@ -9,11 +9,13 @@
  * is inside of the specified range*/
 object DegreeConstrainedFunction : GraphFunction {
 
-    override fun<V> completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) =
+    override fun <V> completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) =
             if (subgraph.vertexSet().any { subgraph.degreeOf(it) > args[0] }) 0 else 1
 
-    override fun <V>eval(g: Graph<V, DefaultEdge>, args: List<Int>): Int {
+    override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>): Int {
         fun rangeBetween(x: Int, y: Int) = if (x <= y) x..y else y..x
         return if (g.vertexSet().all { g.degreeOf(it) in rangeBetween(args[0], args[1]) }) 1 else 0
     }
+
+    override fun degOneOptimum(graphSize: Int) = throw Exception("not implemented yet")
 }
\ No newline at end of file
Index: tests/applicationTests/Acyclic.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package applicationTests\r\n\r\nimport applicationTests.util.Tester\r\nimport de.umr.FilePaths.*\r\nimport de.umr.core.createClique\r\nimport de.umr.core.createPath\r\nimport de.umr.fixcon.graphFunctions.standardFunctions.AcyclicFunction\r\nimport org.junit.jupiter.api.Nested\r\nimport org.junit.jupiter.api.Test\r\n\r\ninternal class Acyclic {\r\n    private val t = Tester(AcyclicFunction)\r\n\r\n    @Nested\r\n    internal inner class infPower {\r\n        @Test\r\n        fun f9() = t.test(1, InfPower, 9)\r\n\r\n        @Test\r\n        fun f14() = t.test(1, InfPower, 14)\r\n\r\n        @Test\r\n        fun f18() = t.test(1, InfPower, 18)\r\n\r\n        @Test\r\n        fun f20() = t.test(1, InfPower, 20)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class usAir {\r\n        @Test\r\n        fun f4() = t.test(1, InfUsAir, 4)\r\n\r\n        @Test\r\n        fun f8() = t.test(1, InfUsAir, 8)\r\n\r\n        @Test\r\n        fun f9() = t.test(1, InfUsAir, 9)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class coPapers {\r\n        @Test\r\n        fun f4() = t.test(1, CoPapersCiteseer, 4)\r\n\r\n        @Test\r\n        fun f7() = t.test(1, CoPapersCiteseer, 7)\r\n\r\n        @Test\r\n        fun f9() = t.test(1, CoPapersCiteseer, 9)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class euroRoad {\r\n        @Test\r\n        fun f4() = t.test(1, InfEuroRoad, 4)\r\n\r\n        @Test\r\n        fun f7() = t.test(1, InfEuroRoad, 7)\r\n\r\n        @Test\r\n        fun f9() = t.test(1, InfEuroRoad, 9)\r\n\r\n        @Test\r\n        fun f13() = t.test(1, InfEuroRoad, 13)\r\n\r\n        @Test\r\n        fun f17() = t.test(1, InfEuroRoad, 17)\r\n\r\n        @Test\r\n        fun f20() = t.test(1, InfEuroRoad, 20)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class openFlights {\r\n        @Test\r\n        fun f4() = t.test(1, InfOpenFlights, 4)\r\n\r\n        @Test\r\n        fun f7() = t.test(1, InfOpenFlights, 7)\r\n\r\n        @Test\r\n        fun f8() = t.test(1, InfOpenFlights, 8)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class clique {\r\n        @Test\r\n        fun f3_2() = t.test(1, createClique(3), 2)\r\n\r\n        @Test\r\n        fun f3_3() = t.test(0, createClique(3), 3)\r\n\r\n        @Test\r\n        fun f23_5() = t.test(0, createClique(23), 5)\r\n\r\n        @Test\r\n        fun f10_9() = t.test(0, createClique(10), 9)\r\n\r\n        @Test\r\n        fun f50_20() = t.test(0, createClique(50), 20)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class path {\r\n        @Test\r\n        fun f_10_5() = t.test(1, createPath(10), 5)\r\n\r\n        @Test\r\n        fun f_3_3() = t.test(1, createPath(3), 3)\r\n\r\n        @Test\r\n        fun f_23_5() = t.test(1, createPath(23), 5)\r\n\r\n        @Test\r\n        fun f_10_9() = t.test(1, createPath(10), 9)\r\n\r\n        @Test\r\n        fun f_50_20() = t.test(1, createPath(50), 20)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class brightkite {\r\n        @Test\r\n        fun f5() = t.test(1, SocBrightkite, 5)\r\n\r\n        @Test\r\n        fun f10() = t.test(1, SocBrightkite, 10)\r\n\r\n        @Test\r\n        fun f12() = t.test(1, SocBrightkite, 12)\r\n\r\n        @Test\r\n        fun f14() = t.test(1, SocBrightkite, 14)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class caSandiAuths {\r\n        @Test\r\n        fun f2() = t.test(1, CaSandiAuths, 2, weighted = true)\r\n\r\n        @Test\r\n        fun f10() = t.test(1, CaSandiAuths, 10, weighted = true)\r\n\r\n        @Test\r\n        fun f12() = t.test(1, CaSandiAuths, 12, weighted = true)\r\n\r\n        @Test\r\n        fun f14() = t.test(1, CaSandiAuths, 14, weighted = true)\r\n\r\n        @Test\r\n        fun f15() = t.test(1, CaSandiAuths, 15, weighted = true)\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/applicationTests/Acyclic.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ tests/applicationTests/Acyclic.kt	(date 1592288716749)
@@ -4,6 +4,7 @@
 import de.umr.FilePaths.*
 import de.umr.core.createClique
 import de.umr.core.createPath
+import de.umr.core.graphFromFile
 import de.umr.fixcon.graphFunctions.standardFunctions.AcyclicFunction
 import org.junit.jupiter.api.Nested
 import org.junit.jupiter.api.Test
@@ -13,74 +14,79 @@
 
     @Nested
     internal inner class infPower {
+        val g = graphFromFile(InfPower)
         @Test
-        fun f9() = t.test(1, InfPower, 9)
+        fun f9() = t.test(1, g, 9)
 
         @Test
-        fun f14() = t.test(1, InfPower, 14)
+        fun f14() = t.test(1, g, 14)
 
         @Test
-        fun f18() = t.test(1, InfPower, 18)
+        fun f18() = t.test(1, g, 18)
 
         @Test
-        fun f20() = t.test(1, InfPower, 20)
+        fun f20() = t.test(1, g, 20)
     }
 
     @Nested
     internal inner class usAir {
+        val g = graphFromFile(InfUsAir)
         @Test
-        fun f4() = t.test(1, InfUsAir, 4)
+        fun f4() = t.test(1, g, 4)
 
         @Test
-        fun f8() = t.test(1, InfUsAir, 8)
+        fun f8() = t.test(1, g, 8)
 
         @Test
-        fun f9() = t.test(1, InfUsAir, 9)
+        fun f9() = t.test(1, g, 9)
     }
 
     @Nested
     internal inner class coPapers {
+        val g = graphFromFile(CoPapersCiteseer)
         @Test
-        fun f4() = t.test(1, CoPapersCiteseer, 4)
+        fun f4() = t.test(1, g, 4)
 
         @Test
-        fun f7() = t.test(1, CoPapersCiteseer, 7)
+        fun f7() = t.test(1, g, 7)
 
         @Test
-        fun f9() = t.test(1, CoPapersCiteseer, 9)
+        fun f9() = t.test(1, g, 9)
     }
 
     @Nested
     internal inner class euroRoad {
+        val g = InfEuroRoad
         @Test
-        fun f4() = t.test(1, InfEuroRoad, 4)
+        fun f4() = t.test(1, g, 4)
 
         @Test
-        fun f7() = t.test(1, InfEuroRoad, 7)
+        fun f7() = t.test(1, g, 7)
 
         @Test
-        fun f9() = t.test(1, InfEuroRoad, 9)
+        fun f9() = t.test(1, g, 9)
 
         @Test
-        fun f13() = t.test(1, InfEuroRoad, 13)
+        fun f13() = t.test(1, g, 13)
 
         @Test
-        fun f17() = t.test(1, InfEuroRoad, 17)
+        fun f17() = t.test(1, g, 17)
 
         @Test
-        fun f20() = t.test(1, InfEuroRoad, 20)
+        fun f20() = t.test(1, g, 20)
     }
 
     @Nested
     internal inner class openFlights {
+        val g = graphFromFile(InfOpenFlights)
         @Test
-        fun f4() = t.test(1, InfOpenFlights, 4)
+        fun f4() = t.test(1, g, 4)
 
         @Test
-        fun f7() = t.test(1, InfOpenFlights, 7)
+        fun f7() = t.test(1, g, 7)
 
         @Test
-        fun f8() = t.test(1, InfOpenFlights, 8)
+        fun f8() = t.test(1, g, 8)
     }
 
     @Nested
@@ -96,9 +102,6 @@
 
         @Test
         fun f10_9() = t.test(0, createClique(10), 9)
-
-        @Test
-        fun f50_20() = t.test(0, createClique(50), 20)
     }
 
     @Nested
@@ -121,17 +124,18 @@
 
     @Nested
     internal inner class brightkite {
+        val g = SocBrightkite
         @Test
-        fun f5() = t.test(1, SocBrightkite, 5)
+        fun f5() = t.test(1, g, 5)
 
         @Test
-        fun f10() = t.test(1, SocBrightkite, 10)
+        fun f10() = t.test(1, g, 10)
 
         @Test
-        fun f12() = t.test(1, SocBrightkite, 12)
+        fun f12() = t.test(1, g, 12)
 
         @Test
-        fun f14() = t.test(1, SocBrightkite, 14)
+        fun f14() = t.test(1, g, 14)
     }
 
     @Nested
Index: src/de/umr/fixcon/graphFunctions/standardFunctions/MinDegreeFunction.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon.graphFunctions.standardFunctions\r\n\r\nimport de.umr.core.dataStructures.VertexOrderedGraph\r\nimport de.umr.core.degreeSequence\r\nimport de.umr.core.vertexCount\r\nimport de.umr.fixcon.graphFunctions.GraphFunction\r\nimport org.jgrapht.Graph\r\nimport org.jgrapht.graph.DefaultEdge\r\n\r\n/**Returns the minimum degree of all vertices in this graph.*/\r\nobject MinDegreeFunction : GraphFunction {\r\n    override val isEdgeMonotone: Boolean = true\r\n\r\n    override fun <V> completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) = targetSize - subgraph.vertexCount\r\n\r\n    override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) =\r\n            g.degreeSequence.min()!!\r\n\r\n\r\n    override fun globalOptimum(graphSize: Int) = graphSize - 1\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/graphFunctions/standardFunctions/MinDegreeFunction.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/graphFunctions/standardFunctions/MinDegreeFunction.kt	(date 1592289269939)
@@ -18,4 +18,6 @@
 
 
     override fun globalOptimum(graphSize: Int) = graphSize - 1
+
+    override fun degOneOptimum(graphSize: Int) = throw Exception("not implemented yet")
 }
\ No newline at end of file
Index: tests/fixcon/heuristics/Randomizer_Test.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package fixcon.heuristics\r\n\r\nimport de.umr.fixcon.heuristics.randomElement\r\nimport org.junit.jupiter.api.Assertions.assertThrows\r\nimport org.junit.jupiter.api.Assertions.assertTrue\r\nimport org.junit.jupiter.api.Test\r\nimport kotlin.math.abs\r\n\r\ninternal class Randomizer_Test {\r\n\r\n    @Test\r\n    fun basic_test() {\r\n        val map = mapOf(3 to 3.0, 1 to 4.6, 10 to 0.0)\r\n        assertTrue(map.containsKey(randomElement(map)))\r\n    }\r\n\r\n    @Test\r\n    fun asymptoticWeighting_test() {\r\n        val map = mapOf(0 to 1.0, 1 to 2.0)\r\n        val runs = 1_000_000\r\n        val relFreq = (1..runs).map { randomElement(map) }.count { it == 0 }.toDouble() / runs\r\n        assertTrue(abs(relFreq - 1.0 / 3) < 0.01)\r\n    }\r\n\r\n    @Test\r\n    fun laplaceDistribution() {\r\n        val runs = 1_000_000\r\n        val freqMap = mutableMapOf<Int, Int>()\r\n        repeat(runs) {\r\n            val randVal = (1..6).random()\r\n            freqMap[randVal] = freqMap.getOrDefault(randVal, 0) + 1\r\n        }\r\n        freqMap.values.forEach { assertTrue(abs(it.toDouble() / runs - 1.0 / 6) < 0.01) }\r\n    }\r\n\r\n    @Test\r\n    fun negativeWeight_Exception_test() {\r\n        assertThrows(IllegalArgumentException::class.java) { randomElement(mapOf(0 to 1.0, 1 to -2.0)) }\r\n    }\r\n\r\n    @Test\r\n    fun weightSumZero_Exception_test() {\r\n        assertThrows(IllegalArgumentException::class.java) { randomElement(mapOf(0 to 0.0, 1 to 0.0)) }\r\n    }\r\n\r\n    @Test\r\n    fun stringCollection_test() =\r\n            repeat(10) { randomElement(mapOf(\"Hund\" to 1.4, \"Katze\" to 2.5, \"Giraffe\" to 23.6)) in setOf(\"Hund\", \"Katze\", \"Giraffe\") }\r\n\r\n    @Test\r\n    fun acceptsMixedTypes_test() =\r\n            repeat(5) { assertTrue(randomElement(mapOf(1 to 1.2, \"hallo\" to 1.5)) in setOf(1, \"hallo\")) }\r\n\r\n    @Test\r\n    fun weightZeroNeverReturned_test() =\r\n            repeat(100) { assertTrue(randomElement(mapOf(\"immer\" to 0.1, \"nie\" to 0.0)) != \"nie\") }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/fixcon/heuristics/Randomizer_Test.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ tests/fixcon/heuristics/Randomizer_Test.kt	(date 1592289999592)
@@ -33,11 +33,6 @@
         freqMap.values.forEach { assertTrue(abs(it.toDouble() / runs - 1.0 / 6) < 0.01) }
     }
 
-    @Test
-    fun negativeWeight_Exception_test() {
-        assertThrows(IllegalArgumentException::class.java) { randomElement(mapOf(0 to 1.0, 1 to -2.0)) }
-    }
-
     @Test
     fun weightSumZero_Exception_test() {
         assertThrows(IllegalArgumentException::class.java) { randomElement(mapOf(0 to 0.0, 1 to 0.0)) }
Index: src/de/umr/fixcon/graphFunctions/standardFunctions/AcyclicFunction.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon.graphFunctions.standardFunctions\r\n\r\nimport de.umr.core.dataStructures.VertexOrderedGraph\r\nimport de.umr.fixcon.graphFunctions.GraphFunction\r\nimport org.jgrapht.Graph\r\nimport org.jgrapht.GraphTests.isTree\r\nimport org.jgrapht.graph.DefaultEdge\r\n\r\n/**This function returns 1 (indicator for **True**) iff the graph is a tree (connected and acyclic).*/\r\nobject AcyclicFunction : GraphFunction {\r\n\r\n    override fun <V>completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) = 0\r\n\r\n    override fun<V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) = if (isTree(g)) 1 else 0\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/graphFunctions/standardFunctions/AcyclicFunction.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/graphFunctions/standardFunctions/AcyclicFunction.kt	(date 1592285897704)
@@ -9,7 +9,9 @@
 /**This function returns 1 (indicator for **True**) iff the graph is a tree (connected and acyclic).*/
 object AcyclicFunction : GraphFunction {
 
-    override fun <V>completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) = 0
+    override fun <V> completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) = 0
 
-    override fun<V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) = if (isTree(g)) 1 else 0
+    override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) = if (isTree(g)) 1 else 0
+
+    override fun degOneOptimum(graphSize: Int) = throw Exception("not implemented yet")
 }
\ No newline at end of file
Index: tests/applicationTests/EdgeCount.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package applicationTests\r\n\r\nimport applicationTests.util.Tester\r\nimport de.umr.FilePaths.*\r\nimport de.umr.fixcon.graphFunctions.standardFunctions.EdgeCountFunction\r\nimport org.junit.jupiter.api.Nested\r\nimport org.junit.jupiter.api.Test\r\n\r\n\r\nprivate class EdgeCount {\r\n    private val t = Tester(EdgeCountFunction)\r\n\r\n    @Nested\r\n    internal inner class usAir {\r\n        @Test\r\n        fun f4() = t.test(6, InfUsAir, 4)\r\n\r\n        @Test\r\n        fun f5() = t.test(10, InfUsAir, 5)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class dmela {\r\n        @Test\r\n        fun f4() = t.test(6, BioDmela, 4)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class socAdvogato {\r\n        @Test\r\n        fun f4() = t.test(6, SocAdvogato, 4)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class coPapers {\r\n        @Test\r\n        fun f4() = t.test(6, CoPapersCiteseer, 4)\r\n\r\n        @Test\r\n        fun f5() = t.test(10, CoPapersCiteseer, 5)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class infPower {\r\n        @Test\r\n        fun f4() = t.test(6, InfPower, 4)\r\n\r\n        @Test\r\n        fun f5() = t.test(10, InfPower, 5)\r\n\r\n        @Test\r\n        fun f6() = t.test(15, InfPower, 6)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class dolphins {\r\n        @Test\r\n        fun f7() = t.test(17, OutDolphins, 7)\r\n\r\n        @Test\r\n        fun f8() = t.test(20, OutDolphins, 8)\r\n    }\r\n\r\n    @Nested\r\n    internal inner class euroRoad {\r\n        @Test\r\n        fun f6() = t.test(8, InfEuroRoad, 6)\r\n\r\n        @Test\r\n        fun f7() = t.test(9, InfEuroRoad, 7)\r\n\r\n        @Test\r\n        fun f8() = t.test(11, InfEuroRoad, 8)\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/applicationTests/EdgeCount.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ tests/applicationTests/EdgeCount.kt	(date 1592286866118)
@@ -2,6 +2,7 @@
 
 import applicationTests.util.Tester
 import de.umr.FilePaths.*
+import de.umr.core.graphFromFile
 import de.umr.fixcon.graphFunctions.standardFunctions.EdgeCountFunction
 import org.junit.jupiter.api.Nested
 import org.junit.jupiter.api.Test
@@ -12,64 +13,78 @@
 
     @Nested
     internal inner class usAir {
+        val g = graphFromFile(InfUsAir)
+
         @Test
-        fun f4() = t.test(6, InfUsAir, 4)
+        fun f4() = t.test(6, g, 4)
 
         @Test
-        fun f5() = t.test(10, InfUsAir, 5)
+        fun f5() = t.test(10, g, 5)
     }
 
     @Nested
     internal inner class dmela {
+        val g = graphFromFile(BioDmela)
+
         @Test
-        fun f4() = t.test(6, BioDmela, 4)
+        fun f4() = t.test(6, g, 4)
     }
 
     @Nested
     internal inner class socAdvogato {
+        val g = graphFromFile(SocAdvogato)
+
         @Test
-        fun f4() = t.test(6, SocAdvogato, 4)
+        fun f4() = t.test(6, g, 4)
     }
 
     @Nested
     internal inner class coPapers {
+        val g = graphFromFile(CoPapersCiteseer)
+
         @Test
-        fun f4() = t.test(6, CoPapersCiteseer, 4)
+        fun f4() = t.test(6, g, 4)
 
         @Test
-        fun f5() = t.test(10, CoPapersCiteseer, 5)
+        fun f5() = t.test(10, g, 5)
     }
 
     @Nested
     internal inner class infPower {
+        val g = graphFromFile(InfPower)
+
         @Test
-        fun f4() = t.test(6, InfPower, 4)
+        fun f4() = t.test(6, g, 4)
 
         @Test
-        fun f5() = t.test(10, InfPower, 5)
+        fun f5() = t.test(10, g, 5)
 
         @Test
-        fun f6() = t.test(15, InfPower, 6)
+        fun f6() = t.test(15, g, 6)
     }
 
     @Nested
     internal inner class dolphins {
+        val g = graphFromFile(OutDolphins)
+
         @Test
-        fun f7() = t.test(17, OutDolphins, 7)
+        fun f7() = t.test(17, g, 7)
 
         @Test
-        fun f8() = t.test(20, OutDolphins, 8)
+        fun f8() = t.test(20, g, 8)
     }
 
     @Nested
     internal inner class euroRoad {
+        val g = graphFromFile(InfEuroRoad)
+
         @Test
-        fun f6() = t.test(8, InfEuroRoad, 6)
+        fun f6() = t.test(8, g, 6)
 
         @Test
-        fun f7() = t.test(9, InfEuroRoad, 7)
+        fun f7() = t.test(9, g, 7)
 
         @Test
-        fun f8() = t.test(11, InfEuroRoad, 8)
+        fun f8() = t.test(11, g, 8)
     }
 }
\ No newline at end of file
Index: src/de/umr/fixcon/graphFunctions/standardFunctions/EdgeCountFunction.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon.graphFunctions.standardFunctions\r\n\r\nimport de.umr.core.dataStructures.VertexOrderedGraph\r\nimport de.umr.core.edgeCount\r\nimport de.umr.core.vertexCount\r\nimport de.umr.fixcon.graphFunctions.GraphFunction\r\nimport org.jgrapht.Graph\r\nimport org.jgrapht.graph.DefaultEdge\r\n\r\n/**This function counts the number of edges in a given graph.*/\r\nobject EdgeCountFunction : GraphFunction {\r\n    override val isEdgeMonotone: Boolean = true\r\n\r\n    /**corresponds to the arithmetic series: subgraph.size + subgraph.size+1 + ... + targetSize-1*/\r\n    override fun <V> completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) =\r\n            (subgraph.vertexCount until targetSize).sum()\r\n\r\n    override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>): Int = g.edgeCount\r\n\r\n    override fun globalOptimum(graphSize: Int) = (graphSize * (graphSize - 1) / 2)\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/graphFunctions/standardFunctions/EdgeCountFunction.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/graphFunctions/standardFunctions/EdgeCountFunction.kt	(date 1592289269957)
@@ -18,4 +18,6 @@
     override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>): Int = g.edgeCount
 
     override fun globalOptimum(graphSize: Int) = (graphSize * (graphSize - 1) / 2)
+
+    override fun degOneOptimum(graphSize: Int) = globalOptimum(graphSize - 1) + 1
 }
\ No newline at end of file
Index: src/de/umr/core/dataStructures/VertexOrderedGraph.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.core.dataStructures\r\n\r\nimport de.umr.core.addWeightedEdge\r\nimport de.umr.core.vertexCount\r\nimport org.jgrapht.graph.DefaultEdge\r\nimport org.jgrapht.graph.SimpleWeightedGraph\r\nimport java.util.*\r\n\r\n/**A modified [SimpleWeightedGraph] that stores the inserted vertices in insertion-order.\r\n *\r\n * @param V Is the type of the vertices in the graph.\r\n *\r\n * It also provides some other utilities not related to vertex-ordering*/\r\nclass VertexOrderedGraph<V> : SimpleWeightedGraph<V, DefaultEdge>(DefaultEdge::class.java) {\r\n\r\n    /**Stores the insertion-order of the vertices in the graph*/\r\n    private val vertexStack: Deque<V> = LinkedList()\r\n\r\n    companion object Factory {\r\n\r\n        private const val defaultEdgeWeight = 1.0\r\n\r\n        /** Creates the graph and adds the vertices in [vertices]*/\r\n        fun <V> fromVertices(vararg vertices: V): VertexOrderedGraph<V> {\r\n            val g = VertexOrderedGraph<V>()\r\n            return g.also { vertices.forEach { g.addVertex(it) } }\r\n        }\r\n\r\n        fun <V> fromWeightedEdges(edges: List<Triple<V, V, Double>>): VertexOrderedGraph<V> {\r\n            require(edges.isNotEmpty())\r\n            val g = VertexOrderedGraph<V>()\r\n            return g.also { for ((v1, v2, weight) in edges) g.addWeightedEdge(v1, v2, weight) }\r\n        }\r\n\r\n        fun <V> fromUnweightedEdges(edges: List<Pair<V, V>>) =\r\n                fromWeightedEdges(edges.map { (v1, v2) -> Triple(v1, v2, defaultEdgeWeight) })\r\n    }\r\n\r\n    /**@return *True* iff the graph changed as a result of the call, so iff the vertex [elem] was not already\r\n     * present in the graph.*/\r\n    override fun addVertex(elem: V) = super.addVertex(elem).also { if (it) vertexStack.push(elem) }\r\n\r\n    /**Removes the last added vertex, if there are any vertices.\r\n     * @return **True** if the graph has changed as a result of the call, so if any vertices were present.*/\r\n    fun removeLastVertex() = (vertexCount > 0).also { if (it) super.removeVertex(vertexStack.pop()) }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/core/dataStructures/VertexOrderedGraph.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/core/dataStructures/VertexOrderedGraph.kt	(date 1592288053716)
@@ -18,22 +18,17 @@
 
     companion object Factory {
 
-        private const val defaultEdgeWeight = 1.0
-
         /** Creates the graph and adds the vertices in [vertices]*/
-        fun <V> fromVertices(vararg vertices: V): VertexOrderedGraph<V> {
-            val g = VertexOrderedGraph<V>()
-            return g.also { vertices.forEach { g.addVertex(it) } }
-        }
+        fun <V> fromVertices(vararg vertices: V): VertexOrderedGraph<V> =
+                VertexOrderedGraph<V>().apply { vertices.forEach { addVertex(it) } }
 
         fun <V> fromWeightedEdges(edges: List<Triple<V, V, Double>>): VertexOrderedGraph<V> {
             require(edges.isNotEmpty())
-            val g = VertexOrderedGraph<V>()
-            return g.also { for ((v1, v2, weight) in edges) g.addWeightedEdge(v1, v2, weight) }
+            return VertexOrderedGraph<V>().apply { for ((v1, v2, weight) in edges) addWeightedEdge(v1, v2, weight) }
         }
 
         fun <V> fromUnweightedEdges(edges: List<Pair<V, V>>) =
-                fromWeightedEdges(edges.map { (v1, v2) -> Triple(v1, v2, defaultEdgeWeight) })
+                fromWeightedEdges(edges.map { (v1, v2) -> Triple(v1, v2, 1.0) })
     }
 
     /**@return *True* iff the graph changed as a result of the call, so iff the vertex [elem] was not already
Index: src/de/umr/fixcon/graphFunctions/standardFunctions/NRegularFunction.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon.graphFunctions.standardFunctions\r\n\r\nimport de.umr.core.dataStructures.VertexOrderedGraph\r\nimport de.umr.fixcon.graphFunctions.GraphFunction\r\nimport org.jgrapht.Graph\r\nimport org.jgrapht.graph.DefaultEdge\r\n\r\n/**This function returns 1 (indicator for **True**) iff the degree of every vertex in the graph\r\n * is exactly the specified Integer.*/\r\nobject NRegularFunction : GraphFunction {\r\n    override fun <V> completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) =\r\n            DegreeConstrainedFunction.completeAdditionBound(subgraph, targetSize, listOf(args[0], args[0]))\r\n\r\n    override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) =\r\n            DegreeConstrainedFunction.eval(g, listOf(args[0], args[0]))\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/graphFunctions/standardFunctions/NRegularFunction.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/graphFunctions/standardFunctions/NRegularFunction.kt	(date 1592289269919)
@@ -13,4 +13,6 @@
 
     override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) =
             DegreeConstrainedFunction.eval(g, listOf(args[0], args[0]))
+
+    override fun degOneOptimum(graphSize: Int) = throw Exception("not implemented yet")
 }
\ No newline at end of file
Index: src/de/umr/fixcon/graphFunctions/standardFunctions/TriangleFreeFunction.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon.graphFunctions.standardFunctions\r\n\r\nimport de.umr.core.hasTriangle\r\nimport de.umr.fixcon.graphFunctions.GraphFunction\r\nimport org.jgrapht.Graph\r\nimport org.jgrapht.graph.DefaultEdge\r\n\r\n/**This function returns 1 (indicator for **True**) iff the graph contains no triangles.*/\r\nobject TriangleFreeFunction : GraphFunction {\r\n    override fun<V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) = if (g.hasTriangle) 0 else 1\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/graphFunctions/standardFunctions/TriangleFreeFunction.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/graphFunctions/standardFunctions/TriangleFreeFunction.kt	(date 1592289269901)
@@ -7,5 +7,7 @@
 
 /**This function returns 1 (indicator for **True**) iff the graph contains no triangles.*/
 object TriangleFreeFunction : GraphFunction {
-    override fun<V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) = if (g.hasTriangle) 0 else 1
+    override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) = if (g.hasTriangle) 0 else 1
+
+    override fun degOneOptimum(graphSize: Int) = throw Exception("not implemented yet")
 }
\ No newline at end of file
Index: src/Main.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>fun main() {\r\n    printIt(\"hallo\")\r\n    printIt()\r\n}\r\n\r\nfun printIt(x: String = \"Elias\") {\r\n    println(x)\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/Main.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/Main.kt	(date 1592296484912)
@@ -1,8 +1,14 @@
+import de.umr.FilePaths
+import de.umr.core.graphFromFile
+import de.umr.core.shareOfDegree
+
 fun main() {
-    printIt("hallo")
-    printIt()
-}
-
-fun printIt(x: String = "Elias") {
-    println(x)
+    for (path in FilePaths.values()) {
+        val g = try {
+            graphFromFile(path, weighted = false)
+        } catch (e: Exception) {
+            graphFromFile(path, weighted = true)
+        }
+        println("${shareOfDegree(g, 1)} \t $path")
+    }
 }
\ No newline at end of file
Index: src/de/umr/fixcon/graphFunctions/standardFunctions/NegMaxDegreeFunction.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon.graphFunctions.standardFunctions\r\n\r\nimport de.umr.core.dataStructures.VertexOrderedGraph\r\nimport de.umr.core.degreeSequence\r\nimport de.umr.fixcon.graphFunctions.GraphFunction\r\nimport org.jgrapht.Graph\r\nimport org.jgrapht.graph.DefaultEdge\r\n\r\n/**Returns the maximum degree of all vertices in this graph.*/\r\nobject NegMaxDegreeFunction : GraphFunction {\r\n    override fun <V> completeAdditionBound(subgraph: VertexOrderedGraph<V>, targetSize: Int, args: List<Int>) = 0\r\n\r\n    override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) = -g.degreeSequence.max()!!\r\n\r\n    override fun globalOptimum(graphSize: Int) = -2\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/graphFunctions/standardFunctions/NegMaxDegreeFunction.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/graphFunctions/standardFunctions/NegMaxDegreeFunction.kt	(date 1592289269884)
@@ -13,4 +13,6 @@
     override fun <V> eval(g: Graph<V, DefaultEdge>, args: List<Int>) = -g.degreeSequence.max()!!
 
     override fun globalOptimum(graphSize: Int) = -2
+
+    override fun degOneOptimum(graphSize: Int) = throw Exception("not implemented yet")
 }
\ No newline at end of file
Index: src/de/umr/fixcon/heuristics/Randomizer.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.umr.fixcon.heuristics\r\n\r\nimport java.lang.IllegalStateException\r\nimport kotlin.random.Random.Default.nextDouble\r\n\r\nfun <T> randomElement(weightMap: Map<T, Double>): T {\r\n\r\n    weightMap.values.forEach { require(it >= 0) }       //only positive weights\r\n    require(weightMap.values.sum() > 0)                 //sum of weights must be positive\r\n\r\n    val randVal = nextDouble(weightMap.values.sum())\r\n    var currWeight = 0.0\r\n\r\n    for ((elem, weight) in weightMap) {\r\n        currWeight += weight\r\n        if (randVal <= currWeight) return elem\r\n    }\r\n\r\n    throw IllegalStateException(\"should never be reached\")\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/fixcon/heuristics/Randomizer.kt	(revision 31ca29773c46b210a7c4a2425901ce0e46500525)
+++ src/de/umr/fixcon/heuristics/Randomizer.kt	(date 1592290416479)
@@ -5,15 +5,12 @@
 
 fun <T> randomElement(weightMap: Map<T, Double>): T {
 
-    weightMap.values.forEach { require(it >= 0) }       //only positive weights
-    require(weightMap.values.sum() > 0)                 //sum of weights must be positive
-
     val randVal = nextDouble(weightMap.values.sum())
     var currWeight = 0.0
 
     for ((elem, weight) in weightMap) {
         currWeight += weight
-        if (randVal <= currWeight) return elem
+        if (currWeight >= randVal) return elem
     }
 
     throw IllegalStateException("should never be reached")
Index: src/de/umr/core/GraphAnalysis.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/de/umr/core/GraphAnalysis.kt	(date 1592285401132)
+++ src/de/umr/core/GraphAnalysis.kt	(date 1592285401132)
@@ -0,0 +1,7 @@
+package de.umr.core
+
+import org.jgrapht.Graph
+import org.jgrapht.graph.DefaultEdge
+
+fun <V> shareOfDegree(g: Graph<V, DefaultEdge>, degree: Int): Double =
+        g.vertexSet().count { g.degreeOf(it) == degree }.toDouble() / g.vertexCount
\ No newline at end of file
